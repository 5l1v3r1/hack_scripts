/*
 Copyright (C) 2014 krabz <krabz@ukr.net>
*/

#include "common.h"
#include <Olectl.h>
#include "ClassFactory.h"


volatile LONG DllRefCount=0;

HINSTANCE hInstance=NULL;
// This our BHO's CLSID. It is a globally unique identifier (GUID) which identifies our BHO's main class to the system. It was generated by the guidgen.exe utility.
// {BFFB193D-2D66-4B8B-9CF9-F67FDEEF6619}
const CLSID CLSID_IEPlugin = { 0xBFFB193D, 0x2D66, 0x4B8B, { 0x9C, 0xF9, 0xF6, 0x7F, 0xDE, 0xEF, 0x66, 0x19 } }; // The CLSID in binary format


BOOL WINAPI DllMain(HINSTANCE hinstDLL,DWORD fdwReason,LPVOID lpvReserved)
{
	UNREFERENCED_PARAMETER(lpvReserved);
	TCHAR mainexe[1024];
	int len;

	if (fdwReason == DLL_PROCESS_ATTACH)
	{ 
		hInstance = hinstDLL; // store our HINSTANCE
		
		DisableThreadLibraryCalls (hInstance); 

		GetModuleFileName (NULL, mainexe, 1024);
		len = _tcsnlen(mainexe,1024);
		if (len > 12 && _tcsicmp (mainexe + len - 12, _T("explorer.exe")) == 0) return FALSE;
	}

	return TRUE;
}

// Called by COM to get a reference to our CClassFactory object
STDAPI DllGetClassObject(REFIID rclsid,REFIID riid,LPVOID *ppv)
{
	HRESULT hr;

	// We only support one class, make sure rclsid matches CLSID_IEPlugin
	if (!IsEqualCLSID (rclsid, CLSID_IEPlugin)) return CLASS_E_CLASSNOTAVAILABLE;

	// Make sure the ppv pointer is valid
	if (IsBadWritePtr(ppv,sizeof(LPVOID))) return E_POINTER;

	(*ppv) = NULL;

	// Create a new CClassFactory object
	CClassFactory *pFactory = new CClassFactory;

	// If we couldn't allocate the new object, return an out-of-memory error
	if (pFactory == NULL) return E_OUTOFMEMORY;

	// Query the pFactory object for the requested interface
	hr = pFactory->QueryInterface (riid, ppv);

	// If the requested interface isn't supported by pFactory, delete the newly created object
	if(FAILED(hr)) delete pFactory;

	// Return the same HRESULT as CClassFactory::QueryInterface
	return hr;
}

// This function is called by COM to determine if the DLL safe to unload.
// We return true if no objects from this DLL are being used and the DLL is unlocked.
STDAPI DllCanUnloadNow()
{
	if(DllRefCount>0) return S_FALSE;
	return S_OK;
}

// This function is called to register our DLL in the system, for example, by regsvr32.exe
// We register ourselves with both COM and Internet Explorer
STDAPI DllRegisterServer()
{
	HKEY hk;
	TCHAR dllpath[1024];
	DWORD n;

	// Get the full path to this DLL's file so we can register it
	GetModuleFileName(hInstance,dllpath,1024);
	// Create our key under HKCR\\CLSID
	
	if (RegCreateKeyEx(HKEY_CLASSES_ROOT,_T("CLSID\\") CLSID_IEPlugin_Str,0,NULL,0,KEY_ALL_ACCESS,NULL,&hk,NULL) != ERROR_SUCCESS)
		return SELFREG_E_CLASS;
	
	// Set the name of our BHO
	RegSetValueEx(hk,NULL,0,REG_SZ,(const BYTE*) PLUGIN_NAME,24*sizeof(TCHAR));
	RegCloseKey(hk);
	
	
	if(RegCreateKeyEx(HKEY_CLASSES_ROOT,_T("CLSID\\") CLSID_IEPlugin_Str _T("\\InProcServer32"),0,NULL,0,KEY_ALL_ACCESS,NULL,&hk,NULL)!=ERROR_SUCCESS) return SELFREG_E_CLASS;
	
	RegSetValueEx(hk,NULL,0,REG_SZ,(const BYTE*)dllpath,(_tcslen(dllpath)+1)*sizeof(TCHAR));
	
	RegSetValueEx(hk,_T("ThreadingModel"),0,REG_SZ,(const BYTE*)_T("Apartment"),10*sizeof(TCHAR));
	RegCloseKey(hk);
	
	// Now register the BHO with Internet Explorer
	if(RegCreateKeyEx(HKEY_LOCAL_MACHINE,_T("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Browser Helper Objects\\") CLSID_IEPlugin_Str,0,NULL,0,KEY_ALL_ACCESS,NULL,&hk,NULL)!=ERROR_SUCCESS) return SELFREG_E_CLASS;
	
	n = 1;
	RegSetValueEx(hk,_T("NoExplorer"),0,REG_DWORD,(const BYTE*)&n,sizeof(DWORD));
	RegCloseKey(hk);

	// force enabling plugin
	if(RegCreateKeyEx(HKEY_CURRENT_USER ,_T("Software\\Microsoft\\Windows\\CurrentVersion\\Ext\\Settings\\") CLSID_IEPlugin_Str,0,NULL,0,KEY_ALL_ACCESS,NULL,&hk,NULL)!=ERROR_SUCCESS) return SELFREG_E_CLASS;
	n = 0;
	RegSetValueEx (hk, _T("Flags"), 0, REG_DWORD, (const BYTE*)&n,sizeof(DWORD));
	RegCloseKey (hk);

	return S_OK;
}

// This function is called to unregister our DLL in the system, for example, by regsvr32.exe
// We remove our registration entries from both COM and Internet Explorer
STDAPI DllUnregisterServer()
{
	// remove plugin enable record
	RegDeleteKey(HKEY_CURRENT_USER,_T("Software\\Microsoft\\Windows\\CurrentVersion\\Ext\\Settings\\") CLSID_IEPlugin_Str);
	// Remove the Internet Explorer BHO registration
	RegDeleteKey(HKEY_LOCAL_MACHINE,_T("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Browser Helper Objects\\") CLSID_IEPlugin_Str);
	// Remove the COM registration, starting with the deeper key first since RegDeleteKey is not recursive
	RegDeleteKey(HKEY_CLASSES_ROOT,_T("CLSID\\") CLSID_IEPlugin_Str _T("\\InProcServer32"));
	RegDeleteKey(HKEY_CLASSES_ROOT,_T("CLSID\\") CLSID_IEPlugin_Str);
	return S_OK;
}
